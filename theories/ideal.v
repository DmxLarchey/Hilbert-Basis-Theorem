(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Ring Setoid Utf8.

Require Import utils ring.

Import ListNotations.

Set Implicit Arguments.

(** The definition of an ideal in a ring *)

Section ring_ideal.

  Variables (ğ“¡ : ring).

  Implicit Types (ğ“˜ ğ“™ : ğ“¡ â†’ Prop).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Definition ring_ideal ğ“˜ :=
      (âˆ€ x y, x âˆ¼áµ£ y â†’ ğ“˜ x â†’ ğ“˜ y)
    âˆ§ ğ“˜ 0áµ£
    âˆ§ (âˆ€ x y, ğ“˜ x â†’ ğ“˜ y â†’ ğ“˜ (x +áµ£ y))
    âˆ§ (âˆ€ x y, ğ“˜ y â†’ ğ“˜ (x *áµ£ y)).

  Fact ring_ideal_equiv ğ“˜ ğ“™ : ğ“˜ â‰¡â‚ ğ“™ â†’ ring_ideal ğ“˜ â†’ ring_ideal ğ“™.
  Proof.
    intros E (H1 & H2 & H3 & H4); split right.
    2: now apply E.
    all: intros ? ?; rewrite <- !E; eauto.
  Qed.

  Variables (ğ“˜ : _ ) (Hğ“˜ : ring_ideal ğ“˜).

  Fact ring_ideal_eq x y : x âˆ¼áµ£ y â†’ ğ“˜ x â†’ ğ“˜ y.
  Proof. apply Hğ“˜ . Qed.

  Fact ring_ideal_op_a : âˆ€ x y, ğ“˜ x â†’ ğ“˜ y â†’ ğ“˜ (x +áµ£ y).
  Proof. apply Hğ“˜. Qed.

  Fact ring_ideal_iv_a x : ğ“˜ x â†’ ğ“˜ (-áµ£ x).
  Proof.
    intros Hx.
    apply (proj1 Hğ“˜) with ((-áµ£ 1áµ£) *áµ£ x); [ ring | ].
    now apply Hğ“˜.
  Qed.

  Hint Resolve ring_ideal_iv_a : core.

  Fact ring_ideal_sub_a x y : ğ“˜ x â†’ ğ“˜ y â†’ ğ“˜ (x âˆ’áµ£ y).
  Proof. intros; apply Hğ“˜; auto. Qed.

End ring_ideal.

Arguments ring_ideal {_}.

(** idl P is the ideal generated by P, ie the smallest ideal containing P *)
Inductive idl {ğ“¡ : ring} (P : ğ“¡ â†’ Prop) : ğ“¡ â†’ Prop :=
  | idl_stop x    : P x â†’ idl P x
  | idl_req x y   : x âˆ¼áµ£ y â†’ idl P x â†’ idl P y 
  | idl_un        : idl P 0áµ£
  | idl_add x y   : idl P x â†’ idl P y â†’ idl P (x +áµ£ y)
  | idl_scal a x  : idl P x â†’ idl P (a *áµ£ x).

#[global] Hint Constructors idl : core.

Add Parametric Morphism (ğ“¡ : ring) (P : ğ“¡ â†’ Prop): (idl P) with signature (req) ==> (iff) as idl_morph.
Proof. intros ? ? E; split; apply (@idl_req _ P); now rewrite E. Qed.

(** An alternate definition for finitely generated ideals using l(inear) c(ombinations) 

    lc l x means (inductively) that x can be obtained as a linear combination of the members of l *)

Inductive lc {ğ“¡ : ring} : list ğ“¡ â†’ ğ“¡ â†’ Prop :=
  | lc_nil  x : 0áµ£ âˆ¼áµ£ x â†’ lc [] x
  | lc_cons a x l z y : a *áµ£ x +áµ£ z âˆ¼áµ£ y â†’ lc l z â†’ lc (x::l) y.

#[global] Hint Constructors lc : core.

Fact lc_req_closed (ğ“¡ : ring) (l : list ğ“¡) x y : x âˆ¼áµ£ y â†’ lc l x â†’ lc l y.
Proof.
  intros H1 H2; revert H2 y H1.
  induction 1 as [ x E | a x l r y E H IH ]; intros z H1.
  + constructor 1; now rewrite E.
  + constructor 2 with a r; auto.
    now rewrite <- H1.
Qed.

Add Parametric Morphism (ğ“¡ : ring) (l : list ğ“¡) : (lc l) with signature (req) ==> (iff) as lc_equiv.
Proof. intros ? ? E; split; apply lc_req_closed; now rewrite E. Qed.

Section ring_ideal.

  Variable (ğ“¡ : ring).

  Implicit Type (x : ğ“¡) (l : list ğ“¡) (P Q ğ“˜ ğ“™ : ğ“¡ â†’ Prop).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Fact idl_ring_ideal P : ring_ideal (idl P).
  Proof. split right; eauto. Qed.

  Hint Resolve idl_ring_ideal : core.

  Fact idl_op_a P x y : idl P x â†’ idl P y â†’ idl P (x +áµ£ y).
  Proof. now constructor 4. Qed.

  Fact idl_iv_a P x : idl P x â†’ idl P (-áµ£ x).
  Proof. apply ring_ideal_iv_a; auto. Qed.

  Hint Resolve idl_op_a idl_iv_a : core.

  Fact idl_sub_a P x y : idl P x â†’ idl P y â†’ idl P (x âˆ’áµ£ y).
  Proof. auto. Qed.

  Fact idl_substract P x y : idl P x â†’ idl P (y âˆ’áµ£ x) â†’ idl P y.
  Proof. intros H1 H2; apply idl_req with (2 := idl_op_a H1 H2); ring. Qed.

  (** idl P is the smallest ideal containing P *)
  Fact idl_smallest P : âˆ€ğ“˜, ring_ideal ğ“˜ â†’ P âŠ†â‚ ğ“˜ â†’ idl P âŠ†â‚ ğ“˜.
  Proof. intros ? (? & ? & ? & ?) ?; induction 1; eauto. Qed.

  Fact idl_mono P Q : P âŠ†â‚ Q â†’ idl P âŠ†â‚ idl Q.
  Proof. intro; apply idl_smallest; auto. Qed.

  Hint Resolve idl_mono : core.
  
  Fact idl_idem P : idl (idl P) âŠ†â‚ idl P.
  Proof. apply idl_smallest; auto. Qed.

  Fact idl_closed P Q : P âŠ†â‚ idl Q â†’ idl P âŠ†â‚ idl Q.
  Proof. apply idl_smallest, idl_ring_ideal. Qed.
  
  #[local] Hint Resolve in_eq in_cons : core.

  Fact idl_stable x l : idl âŒlâŒŸ x â†” idl âŒx::lâŒŸ âŠ†â‚ idl âŒlâŒŸ.
  Proof.
    split.
    + intros ?; apply idl_closed; auto.
      intros ? [ <- | ]; eauto.
    + intros H; apply H; eauto.
  Qed.

  (** Another characterization of idl âŒlâŒŸ *)

  Fact lc__idl l x : lc l x â†’ idl âŒlâŒŸ x.
  Proof.
    induction 1 as [ | a x l r y E _ IH ]; eauto.
    constructor 2 with (1 := E).
    apply idl_op_a; eauto.
    revert IH; apply idl_mono; eauto.
  Qed.

  Fact lc_inv l z :
      lc l z
    â†’ match l with
      | nil  => 0áµ£ âˆ¼áµ£ z
      | x::l => âˆƒ a y, lc l y âˆ§ a *áµ£ x +áµ£ y âˆ¼áµ£ z
      end.
  Proof. destruct 1; eauto. Qed.

  Fact lc_inv_1 x z : lc [x] z â†” âˆƒ a, a *áµ£ x âˆ¼áµ£ z.
  Proof.
     split.
     + intros (u & v & E%lc_inv & F)%lc_inv.
       exists u; rewrite <- F, <- E; ring.
     + intros (a & <-).
       constructor 2 with a un_a; try ring.
       constructor; auto.
  Qed.

  Fact lc_inv_2 x y z : lc [x;y] z â†” âˆƒ a b, a *áµ£ x +áµ£ b *áµ£ y âˆ¼áµ£ z.
  Proof.
     split.
     + intros (u & v & (a & E)%lc_inv_1 & F)%lc_inv.
       exists u, a; rewrite <- F, <- E; ring.
     + intros (a & b & <-).
       constructor 2 with a (op_m b y); try ring.
       constructor 2 with b un_a; try ring.
       constructor; auto.
  Qed.

  Fact lc_un_a l : lc l 0áµ£.
  Proof.
    induction l as [ | x l IHl ].
    + constructor 1; reflexivity.
    + constructor 2 with (a := (op_m un_a x)) (x := x) (z := un_a); auto || ring.
  Qed.

  Hint Resolve lc_un_a : core.

  Fact lc_op_a l x y : lc l x â†’ lc l y â†’ lc l (x +áµ£ y).
  Proof.
    induction 1 as [ x E | a x l r z E H IH ] in y |- *.
    + intros F%lc_inv.
      rewrite <- E, <- F.
      constructor 1; ring.
    + intros (a' & r' & ? & <-)%lc_inv.
      constructor 2 with (a := op_a a a') (z := op_a r r'); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_iv_a l x : lc l x â†’ lc l (iv_a x).
  Proof.
    induction 1 as [ x E | a x l r z E H IH ].
    + constructor 1.
      rewrite <- E; ring.
    + constructor 2 with (a := iv_a a) (z := iv_a r); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_op_m l a x : lc l x â†’ lc l (a *áµ£ x).
  Proof.
    induction 1 as [ x E | b x l r z E H IH ].
    + constructor 1.
      rewrite <- E; ring.
    + constructor 2 with (a := op_m a b) (z := op_m a r); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_incr l x : x âˆˆ l â†’ lc l x.
  Proof.
    revert x; induction l as [ | y l IHl ]; intros x []; subst.
    + constructor 2 with (a := un_m) (z := un_a); auto; ring.
    + apply IHl in H.
      constructor 2 with (a := un_a) (z := x); auto; ring.
  Qed.

  Theorem idl__lc l x : idl âŒlâŒŸ x â†’ lc l x.
  Proof.
    induction 1 as [ x E | x y E | | x y H1 IH1 H2 IH2 | a x H IH ]; auto.
    + now apply lc_incr.
    + now rewrite <- E.
    + now apply lc_op_a.
    + now apply lc_op_m.
  Qed.

  (** We have two equivalent definition of the ideal generated
      by a list l,
      + idl âŒlâŒŸ x: by induction on the structure of x
      + lc l x: by induction on l
    *)

  Theorem idl_iff_lc__list l : idl âŒlâŒŸ â‰¡â‚ lc l.
  Proof.
    split.
    + apply idl__lc.
    + apply lc__idl.
  Qed.

  Hint Resolve in_or_app lc_op_m : core.

  (** More generally, the idl P is the union of lc l for âŒlâŒŸ âŠ†â‚ P *)
  Theorem idl_iff_lc P x : idl P x â†” âˆƒl, lc l x âˆ§ âŒlâŒŸ âŠ†â‚ P.
  Proof.
    split.
    + revert x; apply idl_smallest; [ split right | ].
      * intros x y E (l & H1 & H2); exists l.
        rewrite <- E; auto.
      * exists []; simpl; split; auto; tauto.
      * intros x y (l & H1 & H2) (m & H3 & H4).
        exists (l++m); split.
        - apply idl_iff_lc__list in H1, H3.
          apply idl_iff_lc__list.
          constructor 4.
          ++ revert H1; apply idl_mono; eauto.
          ++ revert H3; apply idl_mono; eauto.
        - intros ? []%in_app_iff; eauto.
      * intros ? ? (l & []); exists l; eauto.
      * intros x ?; exists [x]; split; eauto.
        - apply idl_iff_lc__list; constructor 1; eauto.
        - intros ? [ <- | [] ]; auto.
    + intros (l & H1%idl_iff_lc__list & H2).
      revert H1; now apply idl_mono.
  Qed.

  Lemma idl_compact P l : âŒlâŒŸ âŠ†â‚ idl P â†’ âˆƒm, âŒmâŒŸ âŠ†â‚ P âˆ§ âŒlâŒŸ âŠ†â‚ idl âŒmâŒŸ.
  Proof.
    induction l as [ | x l IHl ].
    + exists []; split; now simpl.
    + intros H.
      cut (idl P x); eauto.
      intros (lx & H1 & H2)%idl_iff_lc.
      destruct IHl as (ll & H3 & H4); eauto.
      exists (lx++ll); split.
      * intros ? []%in_app_iff; auto.
      * intros y  [ <- | Hy%H4 ].
        - apply idl_iff_lc; eauto.
        - revert Hy; apply idl_mono.
          intro; rewrite in_app_iff; auto.
  Qed.

  Inductive update : list ğ“¡ â†’ list ğ“¡ â†’ Prop :=
    | update_chng l x y : lc l (y âˆ’áµ£ x) â†’ update (x::l) (y::l)
    | update_skip x l m : update l m â†’ update (x::l) (x::m).

  Hint Constructors update : core.

  Remark update_sym l m : update l m â†’ update m l.
  Proof.
    induction 1 as [ l x y H%idl_iff_lc__list%idl_iv_a | ]; auto.
    constructor; apply idl_iff_lc__list.
    revert H; apply idl_req; ring.
  Qed.

  Lemma idl_update_closed l m x : update l m â†’ idl âŒlâŒŸ x â†’ idl âŒmâŒŸ x.
  Proof.
    rewrite !idl_iff_lc__list.
    intros H1; revert H1 x.
    induction 1 as [ l x y H1 | x l m _ IH ];
      intros u (a & z & H3 & <-)%lc_inv;
      rewrite <- idl_iff_lc__list in *.
    + apply idl_op_a.
      2: revert H3; apply idl_mono; auto.
      apply idl_scal.
      apply idl_req with (y âˆ’áµ£ (y âˆ’áµ£ x)); try ring.
      apply idl_sub_a; auto.
      revert H1; apply idl_mono; auto.
    + apply idl_op_a.
      * apply idl_scal; constructor 1; now left.
      * apply idl_iff_lc__list, IH, idl_iff_lc__list in H3.
        revert H3; apply idl_mono; auto.
  Qed.

  Hint Resolve update_sym idl_update_closed : core.

  Remark idl_update_invariant l m : update l m â†’ idl âŒlâŒŸ â‰¡â‚ idl âŒmâŒŸ.
  Proof. split; eauto. Qed.

End ring_ideal.

Arguments ring_ideal {_}.
Arguments update {_}.

Definition ring_sub_homo {ğ“¡ ğ“£ : ring} (f : ğ“¡ â†’ ğ“£) :=
   (âˆ€ x y, x âˆ¼áµ£ y â†’ f x âˆ¼áµ£ f y)
 âˆ§ (âˆ€ x y, f (x +áµ£ y) âˆ¼áµ£ f x +áµ£ f y)
 âˆ§ (âˆ€ x y, f (x *áµ£ y) âˆ¼áµ£ f x *áµ£ f y)
 âˆ§ (f 0áµ£ âˆ¼áµ£ 0áµ£).

(** idl P x â†’ idl (f P) (f x) for f ring sub-homomorphism (does not nec. preserve 1áµ£) *)
Fact idl_sub_homo (ğ“¡ ğ“£ : ring) (f : ğ“¡ â†’ ğ“£) :
    ring_sub_homo f
  â†’ âˆ€ (P : ğ“¡ â†’ Prop) x, idl P x â†’ idl (Î» y, âˆƒx, y = f x âˆ§ P x) (f x).
Proof. intros (? & ? & []); induction 1; eauto. Qed.
