(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Coq Require Import List Ring ZArith Znumtheory Setoid Utf8.

Require Import utils ring.

Import ListNotations.

Set Implicit Arguments.

(** Idl P is the ideal generated by P, ie the smallest ideal incu=luding P *)
Inductive Idl {R : ring} (P : R → Prop) : R → Prop :=
  | Idl_stop x    : P x → Idl P x
  | Idl_eq x y    : x ∼ᵣ y → Idl P x → Idl P y 
  | Idl_un        : Idl P 0ᵣ
  | Idl_sub x y   : Idl P x → Idl P y → Idl P (x −ᵣ y)
  | Idl_scal a x  : Idl P x → Idl P (a *ᵣ x).

#[global] Hint Constructors Idl : core.

Add Parametric Morphism (R : ring) (P : R → Prop): (Idl P) with signature (req) ==> (iff) as Idl_morph.
Proof. intros ? ? E; split; apply (@Idl_eq _ P); now rewrite E. Qed.

(** An alternate definition for finitely generated ideals using l(inear) c(ombinations) 

    lc l x means (inductively) that x can be obtained as a linear combination of the members of l *)

Inductive lc {R : ring} : list R → R → Prop :=
  | lc_nil  x : 0ᵣ ∼ᵣ x → lc [] x
  | lc_cons a x l z y : a *ᵣ x +ᵣ z ∼ᵣ y → lc l z → lc (x::l) y.

#[global] Hint Constructors lc : core.

Fact lc_req_closed (R : ring) (l : list R) x y : x ∼ᵣ y → lc l x → lc l y.
Proof.
  intros H1 H2; revert H2 y H1.
  induction 1 as [ x E | a x l r y E H IH ]; intros z H1.
  + constructor 1; now rewrite E.
  + constructor 2 with a r; auto.
    now rewrite <- H1.
Qed.

Add Parametric Morphism (R : ring) (l : list R) : (lc l) with signature (req) ==> (iff) as lc_equiv.
Proof. intros ? ? E; split; apply lc_req_closed; now rewrite E. Qed.

Section ring_ideal.

  Variable (R : ring).

  Implicit Type (x : R) (l : list R) (P Q : R → Prop).

  Add Ring R_is_ring : (is_ring R).

  Definition ring_ideal P :=
       (∀ x y, x ∼ᵣ y → P x → P y)
     ∧ P 0ᵣ
     ∧ (∀ x y, P x → P y → P (x −ᵣ y))
     ∧ (∀ x y, P y → P (x *ᵣ y)).

  Fact ring_ideal_eq P x y : ring_ideal P → x ∼ᵣ y → P x → P y.
  Proof. intros (H & _); apply H. Qed.

  Fact ring_ideal_iv_a P x : ring_ideal P → P x → P (iv_a x).
  Proof.
    intros (H0 & H1 & H2 & H3) ?.
    apply H0 with (x := 0ᵣ −ᵣ x); [ ring | auto ].
  Qed.

  Fact ring_ideal_op_a P : ring_ideal P → ∀ x y, P x → P y → P (x +ᵣ y).
  Proof.
    intros H x y ? ?.
    apply ring_ideal_eq with (x := op_a x (iv_a (iv_a y))); ring || auto.
    apply H; auto. 
    repeat apply ring_ideal_iv_a; auto.
  Qed.

  Fact Idl_ring_ideal P : ring_ideal (Idl P).
  Proof. split right; eauto. Qed.

  Hint Resolve Idl_ring_ideal : core.

  Fact Idl_op_a P x y : Idl P x → Idl P y → Idl P (x +ᵣ y).
  Proof. apply ring_ideal_op_a; auto. Qed.

  (** Idl P is the smallest ideal containing P *)

  Fact Idl_smallest P : ∀Q, ring_ideal Q → P ⊆₁ Q → Idl P ⊆₁ Q.
  Proof. intros ? (? & ? & ? & ?) ?; induction 1; eauto. Qed.

  Fact Idl_mono P Q : P ⊆₁ Q → Idl P ⊆₁ Idl Q.
  Proof. intro; apply Idl_smallest; auto. Qed.

  Hint Resolve Idl_mono : core.
  
  Fact Idl_idem P : Idl (Idl P) ⊆₁ Idl P.
  Proof. apply Idl_smallest; auto. Qed.

  Fact Idl_stable x l : Idl ⌞l⌟ x → Idl ⌞x::l⌟ ⊆₁ Idl ⌞l⌟.
  Proof.
    intros H; apply Idl_smallest; auto.
    intros ? [ <- | ]; eauto.
  Qed.

  (** Another characterization of Idl ⌞l⌟ *)
  
  #[local] Hint Resolve in_eq in_cons (* incl_tl *) : core.

  Fact lc__Idl l x : lc l x → Idl ⌞l⌟ x.
  Proof.
    induction 1 as [ x E | a x l r y E _ IH ]; eauto.
    constructor 2 with (1 := E).
    apply Idl_op_a; eauto.
    revert IH; apply Idl_mono; eauto.
  Qed.

  Fact lc_inv l z :
      lc l z
    → match l with
      | nil  => 0ᵣ ∼ᵣ z
      | x::l => ∃ a y, lc l y ∧ a *ᵣ x +ᵣ y ∼ᵣ z
      end.
  Proof. destruct 1; eauto. Qed.

  Fact lc_inv_1 x z : lc [x] z ↔ ∃ a, a *ᵣ x ∼ᵣ z.
  Proof.
     split.
     + intros (u & v & E%lc_inv & F)%lc_inv.
       exists u; rewrite <- F, <- E; ring.
     + intros (a & <-).
       constructor 2 with a un_a; try ring.
       constructor; auto.
  Qed.

  Fact lc_inv_2 x y z : lc [x;y] z ↔ ∃ a b, a *ᵣ x +ᵣ b *ᵣ y ∼ᵣ z.
  Proof.
     split.
     + intros (u & v & (a & E)%lc_inv_1 & F)%lc_inv.
       exists u, a; rewrite <- F, <- E; ring.
     + intros (a & b & <-).
       constructor 2 with a (op_m b y); try ring.
       constructor 2 with b un_a; try ring.
       constructor; auto.
  Qed.

  Fact lc_un_a l : lc l 0ᵣ.
  Proof.
    induction l as [ | x l IHl ].
    + constructor 1; reflexivity.
    + constructor 2 with (a := (op_m un_a x)) (x := x) (z := un_a); auto || ring.
  Qed.

  Hint Resolve lc_un_a : core.

  Fact lc_op_a l x y : lc l x → lc l y → lc l (x +ᵣ y).
  Proof.
    induction 1 as [ x E | a x l r z E H IH ] in y |- *.
    + intros F%lc_inv.
      rewrite <- E, <- F.
      constructor 1; ring.
    + intros (a' & r' & ? & <-)%lc_inv.
      constructor 2 with (a := op_a a a') (z := op_a r r'); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_iv_a l x : lc l x → lc l (iv_a x).
  Proof.
    induction 1 as [ x E | a x l r z E H IH ].
    + constructor 1.
      rewrite <- E; ring.
    + constructor 2 with (a := iv_a a) (z := iv_a r); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_op_m l a x : lc l x → lc l (a *ᵣ x).
  Proof.
    induction 1 as [ x E | b x l r z E H IH ].
    + constructor 1.
      rewrite <- E; ring.
    + constructor 2 with (a := op_m a b) (z := op_m a r); auto.
      rewrite <- E; ring.
  Qed.

  Fact lc_incr l x : x ∈ l → lc l x.
  Proof.
    revert x; induction l as [ | y l IHl ]; intros x []; subst.
    + constructor 2 with (a := un_m) (z := un_a); auto; ring.
    + apply IHl in H.
      constructor 2 with (a := un_a) (z := x); auto; ring.
  Qed.

  Theorem Idl__lc l x : Idl ⌞l⌟ x → lc l x.
  Proof.
    induction 1 as [ x E | x y E | | x y H1 IH1 H2 IH2 | a x H IH ]; auto.
    + now apply lc_incr.
    + now rewrite <- E.
    + apply lc_op_a; auto.
      apply lc_iv_a; auto.
    + now apply lc_op_m.
  Qed.

  (** We have two equivalent definition of the ideal generated
      by a list l, 
      + Idl ⌞l⌟ x: by induction on the structure of x
      + lc l x: by induction on l
    *)

  Theorem Idl_iff_lc__list l : Idl ⌞l⌟ ≡₁ lc l.
  Proof.
    split.
    + apply Idl__lc.
    + apply lc__Idl.
  Qed.

  Hint Resolve in_or_app lc_op_m : core.

  (** More generally, the Idl P is the union of lc l for ⌞l⌟ ⊆₁ P *)
  Theorem Idl_iff_lc P x : Idl P x ↔ ∃l, lc l x ∧ ⌞l⌟ ⊆₁ P.
  Proof.
    split.
    + revert x; apply Idl_smallest; [ split right | ].
      * intros x y E (l & H1 & H2); exists l.
        rewrite <- E; auto.
      * exists []; simpl; split; auto; tauto.
      * intros x y (l & H1 & H2) (m & H3 & H4).
        exists (l++m); split.
        - apply Idl_iff_lc__list in H1, H3.
          apply Idl_iff_lc__list.
          constructor 4.
          ++ revert H1; apply Idl_mono; eauto.
          ++ revert H3; apply Idl_mono; eauto.
        - intros ? []%in_app_iff; eauto.
      * intros ? ? (l & []); exists l; eauto.
      * intros x ?; exists [x]; split; eauto.
        - apply Idl_iff_lc__list; constructor 1; eauto.
        - intros ? [ <- | [] ]; auto.
    + intros (l & H1%Idl_iff_lc__list & H2).
      revert H1; now apply Idl_mono.
  Qed.

  Lemma Idl_compact P l : ⌞l⌟ ⊆₁ Idl P → ∃m, ⌞m⌟ ⊆₁ P ∧ ⌞l⌟ ⊆₁ Idl ⌞m⌟.
  Proof.
    induction l as [ | x l IHl ].
    + exists []; split; now simpl.
    + intros H.
      cut (Idl P x); eauto.
      intros (lx & H1 & H2)%Idl_iff_lc.
      destruct IHl as (ll & H3 & H4); eauto.
      exists (lx++ll); split.
      * intros ? []%in_app_iff; auto.
      * intros y  [ <- | Hy%H4 ].
        - apply Idl_iff_lc; eauto.
        - revert Hy; apply Idl_mono.
          intro; rewrite in_app_iff; auto.
  Qed.

  Inductive update : list R → list R → Prop :=
    | update_stop l x y z : lc l z → x +ᵣ z ∼ᵣ y → update (x::l) (y::l)
    | update_skip x l m : update l m → update (x::l) (x::m).

  Hint Constructors update : core.

  Fact update_inv l m :
      update l m
    → match l with 
      | []   => False
      | x::l => (∃ z y, lc l z ∧ x +ᵣ z ∼ᵣ y ∧ m = y::l)
              ∨ (∃m', update l m' ∧ m = x::m')
      end.
  Proof. destruct 1; [ left | ]; eauto. Qed.

  Lemma Idl_update_closed l m x : update l m → Idl ⌞l⌟ x → Idl ⌞m⌟ x.
  Proof.
    rewrite !Idl_iff_lc__list.
    intros H1; revert H1 x.
    induction 1 as [ l x y r H1 H2 | x l m _ IH ];
      intros u (a & z & H3 & <-)%lc_inv;
      rewrite <- Idl_iff_lc__list in *.
    + apply Idl_op_a.
      2: revert H3; apply Idl_mono; auto.
      apply Idl_scal.
      apply Idl_morph with (op_a (op_a x r) (iv_a r)); try ring.
      rewrite H2.
      constructor 4.
      * constructor 1; now left.
      * revert H1; apply Idl_mono; auto.
    + apply Idl_op_a.
      * apply Idl_scal; constructor 1; now left.
      * apply Idl_iff_lc__list, IH, Idl_iff_lc__list in H3.
        revert H3; apply Idl_mono; auto.
  Qed.

End ring_ideal.

Arguments ring_ideal {_}.
Arguments update {_}.

Definition ring_div {R : ring} (x y : R) := ∃d, y ∼ᵣ d *ᵣ x .

Notation "x |ᵣ y" := (ring_div x y) (at level 70, no associativity, format "x  |ᵣ  y").

Add Parametric Morphism (R : ring) : (@ring_div R) with signature (req) ==> (req) ==> (iff) as ring_div_a_morph.
Proof.
  intros x y E a b F; split; intros (k & H); exists k.
  + rewrite <- F, H, <- E; reflexivity.
  + rewrite E, <- H, F; reflexivity.
Qed.

Section ring_div.

  Variable (R : ring).

  Add Ring R_is_ring : (is_ring R).

  Implicit Type (x y : R).

  Fact ring_div_refl x : x |ᵣ x.
  Proof. exists un_m; ring. Qed.

  Fact ring_div_trans x y z : x |ᵣ y → y |ᵣ z → x |ᵣ z.
  Proof. intros (a & ->) (b & ->); exists (op_m a b); ring. Qed.

  Fact ring_div_ideal x : ring_ideal (λ y, x |ᵣ y).
  Proof.
    split right.
    + intros ? ? ->; auto.
    + exists un_a; ring.
    + intros ? ? (a & ->) (b & ->); exists (op_a a (iv_a b)); ring.
    + intros u v (a & ->); exists (op_m a u); ring.
  Qed.

End ring_div.

Section principal.

  Variable (R : ring).

  Add Ring R_is_ring : (is_ring R).

  Definition principal_ideal (P : R → Prop) :=
    ∃g, P ≡₁ λ y, g |ᵣ y.

  Fact principal_ideal__ring_ideal P : principal_ideal P → ring_ideal P.
  Proof.
    intros (g & HP); split right.
    + intros u v E H%HP; apply HP; now rewrite <- E.
    + apply HP; exists un_a; ring.
    + intros u v (a & Ha)%HP (b &Hb)%HP; apply HP.
      exists (op_a a (iv_a b)).
      rewrite Ha, Hb; ring.
    + intros u v (a & Ha)%HP; apply HP.
      exists (op_m u a).
      rewrite Ha; ring.
  Qed.

  (* This is not the classical characterization which
     would be every ideal is principal. Here, just every
     finitely generated ideal is principal *)

  Definition principal := ∀l, principal_ideal (Idl ⌞l⌟).

  (* Actually it is enough to show Bezout, i.e. the
     ideal generated by two elements is mono-generated *) 
  Lemma bezout__principal :
       (∀ a b, ∃p : R, lc [a;b] ≡₁ ring_div p)
     → principal.
  Proof.
    intros H l.
    induction l as [ | x l (g & Hg) ].
    + exists un_a; intros x; split.
      * revert x; apply Idl_smallest.
        - apply principal_ideal__ring_ideal; exists un_a; tauto.
        - now simpl.
      * intros (a & ->).
        constructor 2 with un_a.
        - ring.
        - constructor 3.
    + destruct (H g x) as (h & Hh).
      exists h; intros y.
      rewrite Idl_iff_lc__list, <- Hh; split.
      * rewrite lc_inv_2.
        intros (a & r & (k & Hk)%Idl_iff_lc__list%Hg & H2)%lc_inv.
        exists k, a; rewrite <- H2, <- Hk; ring.
      * intros (a & b & <-)%lc_inv_2.
        constructor 2 with b (op_m a g); try ring.
        apply Idl_iff_lc__list, Hg; exists a; ring.
  Qed.

End principal.

Arguments principal_ideal {_}.

Section quotient_principal.

  Variable (R : ring)
           (rel : R → R → Prop)
           (rel_ovr : req ⊆₂ rel) 
           (rel_eqv : Equivalence rel)
           (rel_ext : @ring_eq_ext R op_a op_m iv_a rel).

  Add Ring R_is_ring : (is_ring R).
  Add Ring Q_is_ring : (is_ring (@quotient_ring R rel rel_ovr rel_eqv rel_ext)).

  Hypothesis HR : principal R.

  Fact quotient_principal : principal (@quotient_ring R rel rel_ovr rel_eqv rel_ext).
  Proof.
    apply bezout__principal.
    intros a b.
    destruct (HR [a;b]) as (g & Hg).
    assert (exists u v : R, op_a (op_m u a) (op_m v b) ∼ᵣ g) as (u1 & v1 & Hg').
    1:{ apply lc_inv_2, Idl_iff_lc__list, Hg; exists un_m; ring. }
    exists g; intros x; split.
    + intros (u & v & E)%lc_inv_2; simpl in E.
      assert (ring_div g (op_a (op_m u a) (op_m v b)))
        as (h & Hh).
      * apply Hg, Idl_iff_lc__list.
        simpl; apply lc_inv_2.
        exists u, v; reflexivity.
      * exists h.
        rewrite <- E.
        apply rel_ovr in Hh.
        change ( 
         (@op_a (@quotient_ring R rel rel_ovr rel_eqv rel_ext) (@op_m (@quotient_ring R rel rel_ovr rel_eqv rel_ext) u a)
         (@op_m (@quotient_ring R rel rel_ovr rel_eqv rel_ext) v b)) 
         ∼ᵣ (@op_m (@quotient_ring R rel rel_ovr rel_eqv rel_ext) h g) ) in Hh.
        rewrite -> Hh; reflexivity.
    + intros (k & ->).
      apply lc_inv_2.
      exists (op_m k u1), (op_m k v1).
      apply rel_ovr in Hg'.
      change (@op_a (@quotient_ring R rel rel_ovr rel_eqv rel_ext) 
                    (@op_m (@quotient_ring R rel rel_ovr rel_eqv rel_ext) u1 a) 
                    (@op_m (@quotient_ring R rel rel_ovr rel_eqv rel_ext) v1 b) ∼ᵣ g) 
        in Hg'.
      rewrite <- Hg'.
      ring.
  Qed.

End quotient_principal.

Check quotient_principal.

Definition Z_ring : ring.
Proof.
  exists Z 0%Z Z.add Z.opp 1%Z Z.mul (@eq Z).
  + apply eq_equivalence.
  + apply Zth.
  + abstract (split; intros ? ? []; auto; intros ? ? []; auto).
Defined.


(** Using Bezout's identity, we show that Z is a principal ring *)
Theorem Z_principal : principal Z_ring.
Proof.
  apply bezout__principal.
  intros a b.
  generalize (extgcd_correct a b).
  destruct (extgcd a b) as ((u,v),g); intros H.
  specialize (H _ _ _ eq_refl).
  destruct H as (B & ->).
  exists (Z.gcd a b); split.
  + intros (p & q & E)%lc_inv_2; simpl in E; subst x.
    apply Z.divide_add_r; apply Z.divide_mul_r.
    * apply Z.gcd_divide_l.
    * apply Z.gcd_divide_r.
  + intros (k & ->).
    rewrite <- B.
    apply lc_inv_2.
    exists (k*u), (k*v); simpl; ring.
Qed.

(** Notice that Z[X] is "not a principal ring" because
    the ideal generated by P := 2 and Q := X is not
    principal:
   
    Let us assume that Idl [2;X] were principal, hence
    generated by some polynomial G.
    
    Hence G divides 2 so G is in {-2,-1,1,2}
    But G divides X, hence the head coefficient of G 
    divides that of X, hence G can only be either -1 or 1.
    
    So if Idl [2;X] were principal, then it would
    be generated by 1 (or -1) and hence would be 
    all of Z[X]. Hence 1 belongs to Idl [2;X]
    
    Now let us how that 1 is not a linear combination of 2 and X
    We assume U and V in Z[X] such that U.2+V.X = 1 and derive 
    a contradiction:
    
    We instanciate/evaluate X := 0, we get U(0).2 = 1 in Z
    meaning 2 would divide 1 which is the contradiction we need. 
    
    Notice that Z/pqZ with p prime and q > 1 is a principal
    ring (as a quotient ring). However (Z/pqZ)[X] is not principal
    
    Indeed, let us assume that Idl [p.X⁰;1.X¹] is a principal
    ideal. Then let G be a generator of that ideal.
    We have G divides p.X⁰ so the degree of G is less that 0
    so G = k.X⁰ for some k. Now G divides 1.X¹ so the head
    coefficient of G divides the head coefficient of 1.X¹ hence
    k divides 1. So k is invertible in Z/pqZ, ie gcd(k,pq) = 1.
    
    G is a linear combination of p.X⁰ and 1.X¹ so there is
    U,V in (Z/pqZ)[X] st p.U + X.U = kX⁰. Intanciating
    X with 0, we get p.U(0) = k. Hence p divides k and thus
    divides gcd (k,pq). So p divides 1, hence cannot be prime.
    
    Thm: Z/mZ is principal. But (Z/mZ)[X] is principal if and
         only if Z/mZ is a field, ie m is prime.
*)

(*  
    But by Hilbert's Basis Theorem, Z[X₁,...,Xₙ] is a Noetherian ring
*)
    
(*
    Btw, we can derive Dickson's lemma from the HBT:
    
    to the n-uplet (p₁,...,pₙ) of N^n we associate
    the monomial X^p₁...X^pₙ in Z[X₁,...,Xₙ]. Hence
    a sequence of n-uplet gives rise to a sequence
    of monomials that cannot be forever free of linear
    combinations, according to the HBT. In turn, such
    a linear combination gives a good pair ?

    Mₚ₊₁ = A₁.M₁ + ... + Aₚ.Mₚ
    
    implies one of the M₁,..,Mₚ is lesser than Mₚ₊₁
    on all components
    
    
    
*)




  

