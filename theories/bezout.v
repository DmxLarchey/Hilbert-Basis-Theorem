(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Ring ZArith Znumtheory Setoid Utf8.

Require Import utils ring ideal.

Import ListNotations.

Set Implicit Arguments.

(** Divisibility in a ring *)

Definition ring_div {𝓡 : ring} (x y : 𝓡) := ∃d, y ∼ᵣ d *ᵣ x .

Notation "x |ᵣ y" := (ring_div x y) (at level 70, no associativity, format "x  |ᵣ  y").

Add Parametric Morphism (𝓡 : ring) : (@ring_div 𝓡) with signature (req) ==> (req) ==> (iff) as ring_div_a_morph.
Proof.
  intros x y E a b F; split; intros (k & H); exists k.
  + rewrite <- F, H, <- E; reflexivity.
  + rewrite E, <- H, F; reflexivity.
Qed.

Section ring_div.

  Variable (𝓡 : ring).

  Add Ring 𝓡_is_ring : (is_ring 𝓡).

  Implicit Type (x y : 𝓡).

  Fact ring_div_refl x : x |ᵣ x.
  Proof. exists un_m; ring. Qed.

  Fact ring_div_trans x y z : x |ᵣ y → y |ᵣ z → x |ᵣ z.
  Proof. intros (a & ->) (b & ->); exists (op_m a b); ring. Qed.

  Fact ring_div_ideal x : ring_ideal (λ y, x |ᵣ y).
  Proof.
    split right.
    + intros ? ? ->; auto.
    + exists un_a; ring.
    + intros ? ? (a & ->) (b & ->); exists (a +ᵣ b); ring.
    + intros u v (a & ->); exists (a *ᵣ u); ring.
  Qed.

End ring_div.

(** Principal ideals are mono-generated ideals 

    We define constructivelly principal rings as those where
    each finitely generated ideal is principal. *)

Section principal.

  Variable (𝓡 : ring).

  Add Ring 𝓡_is_ring : (is_ring 𝓡).

  Definition principal_ideal (P : 𝓡 → Prop) :=
    ∃g, P ≡₁ λ y, g |ᵣ y.

  Fact principal_ideal__ring_ideal P : principal_ideal P → ring_ideal P.
  Proof.
    intros (g & Hg); split right.
    + intros u v E H%Hg; apply Hg; now rewrite <- E.
    + apply Hg; exists un_a; ring.
    + intros u v (a & Ha)%Hg (b &Hb)%Hg; apply Hg.
      exists (a +ᵣ b).
      rewrite Ha, Hb; ring.
    + intros u v (a & Ha)%Hg; apply Hg.
      exists (u *ᵣ a).
      rewrite Ha; ring.
  Qed.

  (* In Bezout rings, every finitely generated ideal is principal. 
     We skip the property of being integral here (i.e. the product
     of two elements is zero only if one of those is zero itself. *)

  Definition bezout_ring := ∀l, principal_ideal (idl ⌞l⌟).

  (* Actually, to establish that a ring is Bezout, it is enough to show 
     Bezout, i.e. the ideal generated by two elements is singleton-generated *) 
  Lemma bezout__bezout_ring :
       (∀ a b, ∃p : 𝓡, lc [a;b] ≡₁ ring_div p)
     → bezout_ring.
  Proof.
    intros H l.
    induction l as [ | x l (g & Hg) ].
    + exists un_a; intros x; split.
      * revert x; apply idl_smallest.
        - apply principal_ideal__ring_ideal; exists un_a; tauto.
        - now simpl.
      * intros (a & ->).
        constructor 2 with un_a.
        - ring.
        - constructor 3.
    + destruct (H g x) as (h & Hh).
      exists h; intros y.
      rewrite idl_iff_lc__list, <- Hh; split.
      * rewrite lc_inv_2.
        intros (a & r & (k & Hk)%idl_iff_lc__list%Hg & H2)%lc_inv.
        exists k, a; rewrite <- H2, <- Hk; ring.
      * intros (a & b & <-)%lc_inv_2.
        constructor 2 with b (op_m a g); try ring.
        apply idl_iff_lc__list, Hg; exists a; ring.
  Qed.

End principal.

Arguments principal_ideal {_}.

Section quotient_bezout_ring.

  (* Quotient preserve Bezout rings *)

  Variable (𝓡 : ring)
           (rel : 𝓡 → 𝓡 → Prop)
           (rel_ovr : req ⊆₂ rel) 
           (rel_eqv : Equivalence rel)
           (rel_ext : @ring_eq_ext _ op_a op_m iv_a rel).

  Add Ring 𝓡_is_ring : (is_ring 𝓡).
  Add Ring Q_is_ring : (is_ring (@quotient_ring 𝓡 rel rel_ovr rel_eqv rel_ext)).

  Hypothesis H𝓡 : bezout_ring 𝓡.

  Fact quotient_principal : bezout_ring (@quotient_ring _ rel rel_ovr rel_eqv rel_ext).
  Proof.
    apply bezout__bezout_ring.
    intros a b.
    destruct (H𝓡 [a;b]) as (g & Hg).
    assert (exists u v : 𝓡, op_a (op_m u a) (op_m v b) ∼ᵣ g) as (u1 & v1 & Hg').
    1:{ apply lc_inv_2, idl_iff_lc__list, Hg; exists un_m; ring. }
    exists g; intros x; split.
    + intros (u & v & E)%lc_inv_2; simpl in E.
      assert (ring_div g (op_a (op_m u a) (op_m v b)))
        as (h & Hh).
      * apply Hg, idl_iff_lc__list.
        simpl; apply lc_inv_2.
        exists u, v; reflexivity.
      * exists h.
        rewrite <- E.
        apply rel_ovr in Hh.
        change ( 
         (@op_a (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) u a)
         (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) v b)) 
         ∼ᵣ (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) h g) ) in Hh.
        rewrite -> Hh; reflexivity.
    + intros (k & ->).
      apply lc_inv_2.
      exists (op_m k u1), (op_m k v1).
      apply rel_ovr in Hg'.
      change (@op_a (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) 
                    (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) u1 a) 
                    (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) v1 b) ∼ᵣ g) 
        in Hg'.
      rewrite <- Hg'.
      ring.
  Qed.

End quotient_bezout_ring.

(** Using Bezout's identity, we show that Z is a Bezout ring *)
Theorem Z_bezout_ring : bezout_ring Z_ring.
Proof.
  apply bezout__bezout_ring.
  intros a b.
  generalize (extgcd_correct a b).
  destruct (extgcd a b) as ((u,v),g); intros H.
  specialize (H _ _ _ eq_refl).
  destruct H as (B & ->).
  exists (Z.gcd a b); split.
  + intros (p & q & E)%lc_inv_2; simpl in E; subst x.
    apply Z.divide_add_r; apply Z.divide_mul_r.
    * apply Z.gcd_divide_l.
    * apply Z.gcd_divide_r.
  + intros (k & ->).
    rewrite <- B.
    apply lc_inv_2.
    exists (k*u), (k*v); simpl; ring.
Qed.

(** Notice that Z[X] is "not a Bezout ring" because
    the ideal generated by P := 2 and Q := X is not
    principal:

    Let us assume that idl [2;X] were principal, hence
    generated by some polynomial G.

    Hence G divides 2 so G is in {-2,-1,1,2}
    But G divides X, hence the head coefficient of G 
    divides that of X, hence G can only be either -1 or 1.

    So if idl [2;X] were principal, then it would
    be generated by 1 (or -1) and hence would be 
    all of Z[X]. Hence 1 belongs to idl [2;X]

    Now let us how that 1 is not a linear combination of 2 and X
    We assume U and V in Z[X] such that U.2+V.X = 1 and derive 
    a contradiction:

    We instanciate/evaluate X := 0, we get U(0).2 = 1 in Z
    meaning 2 would divide 1 which is the contradiction we need. 

    Notice that Z/pqZ with p prime and q > 1 is a Bezout ring
    ring (as a quotient ring). However (Z/pqZ)[X] is a Bezout ring.

    Indeed, let us assume that idl [p.X⁰;1.X¹] is a principal
    ideal. Then let G be a generator of that ideal.
    We have G divides p.X⁰ so the degree of G is less that 0
    so G = k.X⁰ for some k. Now G divides 1.X¹ so the head
    coefficient of G divides the head coefficient of 1.X¹ hence
    k divides 1. So k is invertible in Z/pqZ, ie gcd(k,pq) = 1.

    G is a linear combination of p.X⁰ and 1.X¹ so there is
    U,V in (Z/pqZ)[X] st p.U + X.U = kX⁰. Intanciating
    X with 0, we get p.U(0) = k. Hence p divides k and thus
    divides gcd (k,pq). So p divides 1, hence cannot be prime.

    Thm: Z/mZ is a Bezout ring. But (Z/mZ)[X] is Bezout ring 
         if and only if Z/mZ is a field (ie m is prime).
*)



  

