(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Arith Lia Wellfounded Relations Setoid Utf8.

Import ListNotations.

Require Import utils bar ring ideal principal noetherian find_basis.

Section principal__finitely_generated.

  Variables (𝓡 : ring).

  Add Ring 𝓡_is_ring : (is_ring 𝓡).

  Fact fingen__ring_ideal : fingen_ideal ⊆₁ @ring_ideal 𝓡.
  Proof.
    intros P (b & Hb).
    generalize (Idl_ring_ideal _ ⌞b⌟).
    apply ring_ideal_equiv.
    intro; now rewrite Hb.
  Qed.

  Fact principal__fingen_ideal : principal_ideal ⊆₁ @fingen_ideal 𝓡.
  Proof.
    intros P (g & Hg); exists [g].
    intros x; rewrite Hg; split.
    + intros (? & ->); constructor 5; constructor; now left.
    + intros (u & <-)%Idl_iff_lc__list%lc_inv_1; exists u; ring.
  Qed.

  (** nc stands for for non constructive *)

  Definition principal_nc := ring_ideal ⊆₁ @principal_ideal 𝓡.
  Definition noetherian_nc := ring_ideal ⊆₁ @fingen_ideal 𝓡.

  Fact principal__noetherian_nc : principal_nc → noetherian_nc.
  Proof. intros H P HP; now apply principal__fingen_ideal, H. Qed.

End principal__finitely_generated.

Arguments fingen_ideal {_}.
Arguments principal_ideal {_}.

Section noetherian_nc_is_meaningless_constructivelly.

  (** Given any non-trivial ring (0 <> 1) discrete (ie with weakly decidable 
      equality, such as eg Z or even just Z/2Z), if it is Noetherian in the 
      non-constructive sense (all ideals are finitely generated) then XM holds. *)

  Variable (𝓡 : ring).

  Add Ring 𝓡_is_ring : (is_ring 𝓡).

  Implicit Type (P : Prop) (𝓘 : 𝓡 → Prop) (x : 𝓡).

  (* The set { x | x ∼ᵣ 0ᵣ ∨ P } is an ideal *)
  Let 𝓙 P x := x ∼ᵣ 0ᵣ ∨ P.

  Local Fact 𝓙_ideal P : ring_ideal (𝓙 P).
  Proof.
    split right.
    + intros ? ? E []; [ left | right ]; auto; now rewrite <- E.
    + now left.
    + intros ? ? [ H1 | ] [ H2 | ]; red; auto; left; rewrite H1, H2; ring.
    + intros ? ? [ H | ]; red; auto; left; rewrite H; ring.
  Qed.

  (* We assume that 𝓡 is discrete and 1ᵣ ≠ 0ᵣ
     which holds already of Z or Z/nZ (n > 1) *)

  Hypothesis (eq_dec : ∀ x y, x ∼ᵣ y ∨ ¬ x ∼ᵣ y)
             (zero_not_one : ¬ 1ᵣ ∼ᵣ @un_a 𝓡).

  Theorem finitely_gen__discriminate P : ∃𝓘, ring_ideal 𝓘 ∧ (fingen_ideal 𝓘 → P ∨ ¬ P).
  Proof.
    exists (𝓙 P); split.
    1: apply 𝓙_ideal.
    intros (l & Hl).
    (* Either l contains only 0ᵣ or some member of l is ≠ 0ᵣ *)
    destruct list_choice
      with (P := λ x, x ∼ᵣ 0ᵣ)
           (Q := λ x, ¬ x ∼ᵣ 0ᵣ)
           (l := l)
      as [ (x & H1 & H2) | H ]; auto.
    + (* If x ≠ 0ᵣ belongs to l (hence 𝓙 P), then P must hold *)
      left; cut (𝓙 P x).
      * intros []; tauto.
      * apply Hl; now constructor.
    + (* If l only contains 0ᵣ then 𝓙 P, the ideal generated by l
         is {0ᵣ} and thus P cannot hold otherwise 1ᵣ would belong to 𝓙 P *)
      assert (Hl' : ∀x, Idl ⌞l⌟ x → x ∼ᵣ 0ᵣ).
      1:{ apply Idl_smallest; auto.
          split right; eauto.
          * intros ? ? -> ->; ring.
          * intros ? ? ->; ring. }
      right.
      intros H1.
      apply zero_not_one, Hl', Hl; now right.
  Qed.

  Corollary noetherian_nc_implies_XM : noetherian_nc 𝓡 → ∀P, P ∨ ¬ P.
  Proof.
    intros ? P.
    destruct (finitely_gen__discriminate P) as (? & []); eauto.
  Qed.

  Corollary principal_nc_implies_XM : principal_nc 𝓡 → ∀P, P ∨ ¬ P.
  Proof. intro; now apply noetherian_nc_implies_XM, principal__noetherian_nc. Qed.

End noetherian_nc_is_meaningless_constructivelly.

(** So constructivelly, the classical definition of Noetherian
    (and also principal) is useless because unless XM holds (and 
    then we are not constructive anymore), all usefull rings are 
    not going be Noetherian (nor principal). 

    So we need another definition of Noetherian and this is the
    definition given by Coquand & Perrson which works for
    establishing HBT constructivelly. Moreover, we will show
    that using XM, one can prove that this definition implies
    (is equivalent?) the classical definition. *)

Check noetherian_nc_implies_XM.

(** Show that under XM and dependent choice, the constructive definition
    of Noetherian and the classical one coincide: with XM, one can actually show that
    in constructively Noetherian rings all ideals are finitely generated.

    We now study under which conditions an ideal can be proved finitely generated
    constructively. We already explained how the classically understood Noetherianess
    (non-decidable) ideals of Z/2Z can be used to establish excluded middle. So
    we need some assumptions on ideals to show that they are finitely generated
    in a constructive ways. *)

Section noetherian__noetherian_nc__XM.

  Hypothesis xm : ∀P, P ∨ ¬ P.

  Theorem noetherian__noetherian_nc__XM : noetherian ⊆₁ noetherian_nc.
  Proof.
    intros R HR P HP.
    apply find_basis; auto.
    intro; apply incl_witnessed_dec__XM, xm.
  Qed.

  Hypothesis dc : ∀ A (R : A → A → Prop), (∀a, ∃b, R a b) → ∀a, ∃ρ, ρ 0 = a ∧ ∀n, R (ρ n) (ρ (1+n)).

  Theorem noetherian_nc__noetherian : noetherian_nc ⊆₁ noetherian.
  Proof.
    intros R HR; red.
    destruct (xm (@bar R linearly_dependent [])) as [ | C ]; auto; exfalso.
    apply not_bar_nil__XM_DC in C as (rho & Hrho); auto.
    set (img x := ∃n, rho n = x).
    destruct (HR (Idl img)) as (l & Hl).
    1: apply Idl_ring_ideal.
    destruct (@Idl_compact _ img l) as (m & H1 & H2).
    1: intro; rewrite Hl; eauto.
    apply reif_Forall2 in H1 as (k & Hk).
    assert (∃b, ⌞m⌟ ⊆₁ ⌞pfx_rev rho b⌟) as (b & Hb).
    + exists (S (lmax k)).
      intros x Hx.
      apply in_pfx_rev.
      apply Forall2_in_inv_l with (1 := Hk) in Hx
        as (n & []).
      exists n; split; auto.
      now apply le_n_S, lmax_in.
    + apply (Hrho (S b)); simpl.
      constructor 1.
      apply Idl_mono with (P := ⌞m⌟), Idl_idem, Idl_mono with (P := ⌞l⌟); auto.
      apply Hl; constructor 1; now exists b.
  Qed.

End noetherian__noetherian_nc__XM.

