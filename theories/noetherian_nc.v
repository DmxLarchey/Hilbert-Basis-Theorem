(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Coq Require Import List Arith Lia Wellfounded Relations Setoid Utf8.

From KruskalTrees Require Import idx.

Import ListNotations idx_notations.

Require Import utils bar ring ideal noetherian find_basis.

Arguments principal_ideal {R}.

Section principal__finitely_generated.

  Variables (R : ring).

  Add Ring R_is_ring : (is_ring R).

  Implicit Type (I : R → Prop).

  Definition fingen_ideal I := ∃l, I ≡₁ Idl ⌞l⌟.
 (* Definition principal_ideal I := ∃g, I ≡₁ λ y, g |ᵣ y. *) (* defined in ideal.v *)

  Fact fingen__ring_ideal : fingen_ideal ⊆₁ ring_ideal.
  Proof.
    intros P (l & Hl); split right.
    + intros u v E H%Hl; apply Hl; now rewrite <- E.
    + apply Hl; constructor 3.
    + intros u v ?%Hl ?%Hl; apply Hl; now constructor.
    + intros u v ?%Hl; apply Hl; now constructor.
  Qed.

  Fact principal__fingen_ideal : principal_ideal ⊆₁ fingen_ideal.
  Proof.
    intros P (g & Hg); exists [g].
    intros x; rewrite Hg; split.
    + intros (? & ->); constructor 5; constructor; now left.
    + intros (u & <-)%Idl_iff_lc__list%lc_inv_1; exists u; ring.
  Qed.

  (** nc stands for for non constructive *)

  Definition principal_nc := ring_ideal ⊆₁ @principal_ideal R.
  Definition noetherian_nc := ring_ideal ⊆₁ fingen_ideal.

  Fact principal__noetherian_nc : principal_nc → noetherian_nc.
  Proof. intros H P HP; now apply principal__fingen_ideal, H. Qed.

End principal__finitely_generated.

Arguments fingen_ideal {_}.
Arguments principal_ideal {_}.

Section noetherian_nc_is_meaningless_constructivelly.

  (** Given any non-trivial ring (0 <> 1) with weakly decidable equality 
      (such as eg Z or even just Z/2Z), if it is Noetherian in the 
      non-constructive sense (all ideals are finitely generated) 
      then XM holds. *)

  Variable (R : ring).

  Add Ring R_is_ring : (is_ring R).

  Implicit Type (A : Prop) (I : R → Prop).

  (* The set { x | x ∼ᵣ 0ᵣ ∨ A } is an ideal *)
  Let P A (x : R) := x ∼ᵣ 0ᵣ ∨ A.

  Local Fact P_ideal A : ring_ideal (P A).
  Proof.
    split right.
    + intros ? ? E []; [ left | right ]; auto; now rewrite <- E.
    + now left.
    + intros ? ? [ H1 | ] [ H2 | ]; red; auto; left; rewrite H1, H2; ring.
    + intros ? ? [ H | ]; red; auto; left; rewrite H; ring.
  Qed.

  (* We assume that R has weakly decidable equality and 1ᵣ ≠ 0ᵣ
     which holds already of Z or Z/nZ (n > 1) *)

  Hypothesis (Rdec : ∀ x y : R, x ∼ᵣ y ∨ ¬ x ∼ᵣ y)
             (HR : ¬ 1ᵣ ∼ᵣ @un_a R).

  Theorem finitely_gen__discriminate A : ∃I, ring_ideal I ∧ (fingen_ideal I → A ∨ ¬ A).
  Proof.
    exists (P A); split.
    1: apply P_ideal.
    intros (l & HP).
    (* Either l contains only 0ᵣ or some member of l is ≠ 0ᵣ *)
    destruct list_choice
      with (P := λ x : R, x ∼ᵣ 0ᵣ)
           (Q := λ x : R, ¬ x ∼ᵣ 0ᵣ)
           (l := l)
      as [ H | (x & H1 & H2) ]; auto.
    + (* If l only contains 0ᵣ then P A, the ideal generated by l 
         is {0ᵣ} and thus A cannot hold otherwise 1ᵣ would belong to P A *)
      assert (Hl : ∀x, Idl ⌞l⌟ x → x ∼ᵣ 0ᵣ).
      1:{ apply Idl_smallest; auto.
          split right; eauto.
          * intros ? ? -> ->; ring.
          * intros ? ? ->; ring. }
      right.
      intros H1.
      apply HR, Hl, HP; now right.
    + (* If x ≠ 0ᵣ belongs to l (hence P A), then A must hold *)
      left; cut (P A x).
      * intros []; tauto.
      * apply HP; now constructor.
  Qed.

  Corollary noetherian_nc_implies_XM : noetherian_nc R → ∀A, A ∨ ¬ A.
  Proof.
    intros H A.
    destruct (finitely_gen__discriminate A) as (I & H1 & H2).
    apply H2, H, H1.
  Qed.

  Corollary principal_nc_implies_XM : principal_nc R → ∀A, A ∨ ¬ A.
  Proof. intro; now apply noetherian_nc_implies_XM, principal__noetherian_nc. Qed.

End noetherian_nc_is_meaningless_constructivelly.

(** So constructivelly, the classical definition of Noetherian
    (and also principal) is useless because unless XM holds (and 
    then we are not constructive anymore), all usefull rings are 
    not going be Noetherian (nor principal). 

    So we need another definition of Noetherian and this is the
    definition given by Coquand & Perrson which works for
    establishing HBT constructivelly. Moreover, we will show
    that using XM, one can prove that this definition implies
    (is equivalent?) the classical definition. *)
    
Check noetherian_nc_implies_XM.

(** Show that under XM and dependent choice, the constructive definition
    of Noetherian and the classical one coincide: with XM, one can actually show that
    in constructively Noetherian rings aall ideals are finitely generated.

    We now study under which conditions an ideal can be proved finitely generated 
    constructively. We already explained how the classically understood Noetherianess
    (non-decidable) ideals of Z/2Z can be used to establish excluded middle. So
    we need some assumptions on ideals to show that they are finitely generated
    in a constructive ways. *)

Section noetherian__noetherian_nc__XM.

  Hypothesis xm : ∀A, A ∨ ¬ A.

  Theorem noetherian__noetherian_nc__XM : noetherian ⊆₁ noetherian_nc.
  Proof.
    intros R HR P HP.
    apply find_basis; auto.
    intros l.
    destruct xm with (A := ∃x, P x ∧ ¬ Idl ⌞l⌟ x); auto.
    right.
    intros x Hp.
    destruct xm with (A := Idl ⌞l⌟ x); auto.
    destruct H; eauto.
  Qed.

  Hypothesis dc : ∀ X (R : X → X → Prop), (∀x, ∃y, R x y) → ∀x, ∃ρ, ρ 0 = x ∧ ∀n, R (ρ n) (ρ (1+n)).
  
  Theorem noetherian_nc__noetherian : noetherian_nc ⊆₁ noetherian.
  Proof.
    intros R HR; red.
    destruct (xm (@bar R linearly_dependent [])) as [ | C ]; auto; exfalso.
    apply not_bar_nil__XM_DC in C as (rho & Hrho); auto.
    set (img x := ∃n, rho n = x).
    destruct (HR (Idl img)) as (l & Hl).
    1: apply Idl_ring_ideal.
    destruct (@Idl_compact _ img l) as (m & H1 & H2).
    1: intro; rewrite Hl; eauto.
    apply reif_Forall2 in H1 as (k & Hk).
    assert (∃b, ⌞m⌟ ⊆₁ ⌞pfx_rev rho b⌟) as (b & Hb).
    + exists (S (lmax k)).
      intros x Hx.
      apply in_pfx_rev.
      apply Forall2_in_inv_l with (1 := Hk) in Hx
        as (n & []).
      exists n; split; auto.
      now apply le_n_S, lmax_in.
    + apply (Hrho (S b)); simpl.
      constructor 1.
      apply Idl_mono with (P := ⌞m⌟), Idl_idem, Idl_mono with (P := ⌞l⌟); auto.
      apply Hl; constructor 1; now exists b.
  Qed.
  
  (** Question what constructive definition for principal ideals *)

End noetherian__noetherian_nc__XM.

