(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Arith Lia Wellfounded Relations Setoid Utf8.

Import ListNotations.

Require Import utils bar ring ideal principal noetherian find_basis.

Section principal__finitely_generated.

  Variables (ğ“¡ : ring).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Fact fingen__ring_ideal : fingen_ideal âŠ†â‚ @ring_ideal ğ“¡.
  Proof.
    intros P (b & Hb).
    generalize (Idl_ring_ideal _ âŒbâŒŸ).
    apply ring_ideal_equiv.
    intro; now rewrite Hb.
  Qed.

  Fact principal__fingen_ideal : principal_ideal âŠ†â‚ @fingen_ideal ğ“¡.
  Proof.
    intros P (g & Hg); exists [g].
    intros x; rewrite Hg; split.
    + intros (? & ->); constructor 5; constructor; now left.
    + intros (u & <-)%Idl_iff_lc__list%lc_inv_1; exists u; ring.
  Qed.

  (** nc stands for for non constructive *)

  Definition principal_nc := ring_ideal âŠ†â‚ @principal_ideal ğ“¡.
  Definition noetherian_nc := ring_ideal âŠ†â‚ @fingen_ideal ğ“¡.

  Fact principal__noetherian_nc : principal_nc â†’ noetherian_nc.
  Proof. intros H P HP; now apply principal__fingen_ideal, H. Qed.

End principal__finitely_generated.

Arguments fingen_ideal {_}.
Arguments principal_ideal {_}.

Section noetherian_nc_is_meaningless_constructivelly.

  (** Given any non-trivial ring (0 <> 1) discrete (ie with weakly decidable 
      equality, such as eg Z or even just Z/2Z), if it is Noetherian in the 
      non-constructive sense (all ideals are finitely generated) then XM holds. *)

  Variable (ğ“¡ : ring).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Implicit Type (P : Prop) (ğ“˜ : ğ“¡ â†’ Prop) (x : ğ“¡).

  (* The set { x | x âˆ¼áµ£ 0áµ£ âˆ¨ P } is an ideal *)
  Let ğ“™ P x := x âˆ¼áµ£ 0áµ£ âˆ¨ P.

  Local Fact ğ“™_ideal P : ring_ideal (ğ“™ P).
  Proof.
    split right.
    + intros ? ? E []; [ left | right ]; auto; now rewrite <- E.
    + now left.
    + intros ? ? [ H1 | ] [ H2 | ]; red; auto; left; rewrite H1, H2; ring.
    + intros ? ? [ H | ]; red; auto; left; rewrite H; ring.
  Qed.

  (* We assume that ğ“¡ is discrete and 1áµ£ â‰  0áµ£
     which holds already of Z or Z/nZ (n > 1) *)

  Hypothesis (eq_dec : âˆ€ x y, x âˆ¼áµ£ y âˆ¨ Â¬ x âˆ¼áµ£ y)
             (zero_not_one : Â¬ 1áµ£ âˆ¼áµ£ @un_a ğ“¡).

  Theorem finitely_gen__discriminate P : âˆƒğ“˜, ring_ideal ğ“˜ âˆ§ (fingen_ideal ğ“˜ â†’ P âˆ¨ Â¬ P).
  Proof.
    exists (ğ“™ P); split.
    1: apply ğ“™_ideal.
    intros (l & Hl).
    (* Either l contains only 0áµ£ or some member of l is â‰  0áµ£ *)
    destruct list_choice
      with (P := Î» x, x âˆ¼áµ£ 0áµ£)
           (Q := Î» x, Â¬ x âˆ¼áµ£ 0áµ£)
           (l := l)
      as [ (x & H1 & H2) | H ]; auto.
    + (* If x â‰  0áµ£ belongs to l (hence ğ“™ P), then P must hold *)
      left; cut (ğ“™ P x).
      * intros []; tauto.
      * apply Hl; now constructor.
    + (* If l only contains 0áµ£ then ğ“™ P, the ideal generated by l
         is {0áµ£} and thus P cannot hold otherwise 1áµ£ would belong to ğ“™ P *)
      assert (Hl' : âˆ€x, Idl âŒlâŒŸ x â†’ x âˆ¼áµ£ 0áµ£).
      1:{ apply Idl_smallest; auto.
          split right; eauto.
          * intros ? ? -> ->; ring.
          * intros ? ? ->; ring. }
      right.
      intros H1.
      apply zero_not_one, Hl', Hl; now right.
  Qed.

  Corollary noetherian_nc_implies_XM : noetherian_nc ğ“¡ â†’ âˆ€P, P âˆ¨ Â¬ P.
  Proof.
    intros ? P.
    destruct (finitely_gen__discriminate P) as (? & []); eauto.
  Qed.

  Corollary principal_nc_implies_XM : principal_nc ğ“¡ â†’ âˆ€P, P âˆ¨ Â¬ P.
  Proof. intro; now apply noetherian_nc_implies_XM, principal__noetherian_nc. Qed.

End noetherian_nc_is_meaningless_constructivelly.

(** So constructivelly, the classical definition of Noetherian
    (and also principal) is useless because unless XM holds (and 
    then we are not constructive anymore), all usefull rings are 
    not going be Noetherian (nor principal). 

    So we need another definition of Noetherian and this is the
    definition given by Coquand & Perrson which works for
    establishing HBT constructivelly. Moreover, we will show
    that using XM, one can prove that this definition implies
    (is equivalent?) the classical definition. *)

Check noetherian_nc_implies_XM.

(** Show that under XM and dependent choice, the constructive definition
    of Noetherian and the classical one coincide: with XM, one can actually show that
    in constructively Noetherian rings all ideals are finitely generated.

    We now study under which conditions an ideal can be proved finitely generated
    constructively. We already explained how the classically understood Noetherianess
    (non-decidable) ideals of Z/2Z can be used to establish excluded middle. So
    we need some assumptions on ideals to show that they are finitely generated
    in a constructive ways. *)

Section noetherian__noetherian_nc__XM.

  Hypothesis xm : âˆ€P, P âˆ¨ Â¬ P.

  Theorem noetherian__noetherian_nc__XM : noetherian âŠ†â‚ noetherian_nc.
  Proof.
    intros R HR P HP.
    apply find_basis; auto.
    intro; apply incl_witnessed_dec__XM, xm.
  Qed.

  Hypothesis dc : âˆ€ A (R : A â†’ A â†’ Prop), (âˆ€a, âˆƒb, R a b) â†’ âˆ€a, âˆƒÏ, Ï 0 = a âˆ§ âˆ€n, R (Ï n) (Ï (1+n)).

  Theorem noetherian_nc__noetherian : noetherian_nc âŠ†â‚ noetherian.
  Proof.
    intros R HR; red.
    destruct (xm (@bar R linearly_dependent [])) as [ | C ]; auto; exfalso.
    apply not_bar_nil__XM_DC in C as (rho & Hrho); auto.
    set (img x := âˆƒn, rho n = x).
    destruct (HR (Idl img)) as (l & Hl).
    1: apply Idl_ring_ideal.
    destruct (@Idl_compact _ img l) as (m & H1 & H2).
    1: intro; rewrite Hl; eauto.
    apply reif_Forall2 in H1 as (k & Hk).
    assert (âˆƒb, âŒmâŒŸ âŠ†â‚ âŒpfx_rev rho bâŒŸ) as (b & Hb).
    + exists (S (lmax k)).
      intros x Hx.
      apply in_pfx_rev.
      apply Forall2_in_inv_l with (1 := Hk) in Hx
        as (n & []).
      exists n; split; auto.
      now apply le_n_S, lmax_in.
    + apply (Hrho (S b)); simpl.
      constructor 1.
      apply Idl_mono with (P := âŒmâŒŸ), Idl_idem, Idl_mono with (P := âŒlâŒŸ); auto.
      apply Hl; constructor 1; now exists b.
  Qed.

End noetherian__noetherian_nc__XM.

