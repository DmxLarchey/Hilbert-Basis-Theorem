(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Arith Lia Wellfounded Relations Setoid Utf8.

Import ListNotations.

Require Import utils bar ring ideal bezout noetherian.

Section principal__finitely_generated.

  Variables (ğ“¡ : ring).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Fact principal_ideal__fg_ideal : principal_ideal âŠ†â‚ @fg_ideal ğ“¡.
  Proof.
    intros P (g & Hg); exists [g].
    intros x; rewrite Hg; split.
    + intros (? & ->); constructor 5; constructor; now left.
    + intros (u & <-)%idl_iff_lc__list%lc_inv_1; exists u; ring.
  Qed.

  (** nc stands for for non constructive *)

  Definition principal_nc := ideal âŠ†â‚ @principal_ideal ğ“¡.
  Definition noetherian_nc := ideal âŠ†â‚ @fg_ideal ğ“¡.

  Fact principal__noetherian_nc : principal_nc â†’ noetherian_nc.
  Proof. intros H P HP; now apply principal_ideal__fg_ideal, H. Qed.

End principal__finitely_generated.

Section noetherian_nc_is_meaningless_constructivelly.

  (** Given any non-trivial ring (0 <> 1) discrete (ie with logically decidable 
      equality, such as eg Z or even just Z/2Z), if it is Noetherian in the 
      non-constructive sense (all ideals are finitely generated) then XM holds. *)

  Variable (ğ“¡ : ring).

  Add Ring ğ“¡_is_ring : (is_ring ğ“¡).

  Implicit Type (P : Prop) (ğ“˜ : ğ“¡ â†’ Prop) (x : ğ“¡).

  (* The set { x | x âˆ¼áµ£ 0áµ£ âˆ¨ P } is an ideal *)
  Let ğ“™ P x := x âˆ¼áµ£ 0áµ£ âˆ¨ P.

  Local Fact ğ“™_ideal P : ideal (ğ“™ P).
  Proof.
    split right.
    + intros ? ? E []; [ left | right ]; auto; now rewrite <- E.
    + now left.
    + intros ? ? [ H1 | ] [ H2 | ]; red; auto; left; rewrite H1, H2; ring.
    + intros ? ? [ H | ]; red; auto; left; rewrite H; ring.
  Qed.

  (* We assume that ğ“¡ is discrete and 1áµ£ â‰  0áµ£
     which holds already of Z or Z/nZ (n > 1) *)

  Hypothesis (eq_dec : âˆ€ x y, x âˆ¼áµ£ y âˆ¨ Â¬ x âˆ¼áµ£ y)
             (zero_not_one : Â¬ 1áµ£ âˆ¼áµ£ @un_a ğ“¡).

  Theorem finitely_gen__discriminate P : âˆƒğ“˜, ideal ğ“˜ âˆ§ (fg_ideal ğ“˜ â†’ P âˆ¨ Â¬ P).
  Proof.
    exists (ğ“™ P); split.
    1: apply ğ“™_ideal.
    intros (l & Hl).
    (* Either l contains only 0áµ£ or some member of l is â‰  0áµ£ *)
    destruct list_choice
      with (P := Î» x, x âˆ¼áµ£ 0áµ£)
           (Q := Î» x, Â¬ x âˆ¼áµ£ 0áµ£)
           (l := l)
      as [ (x & H1 & H2) | H ]; auto.
    + (* If x â‰  0áµ£ belongs to l (hence ğ“™ P), then P must hold *)
      left; cut (ğ“™ P x).
      * intros []; tauto.
      * apply Hl; now constructor.
    + (* If l only contains 0áµ£ then ğ“™ P, the ideal generated by l
         is {0áµ£} and thus P cannot hold otherwise 1áµ£ would belong to ğ“™ P *)
      assert (Hl' : âˆ€x, idl âŒlâŒŸ x â†’ x âˆ¼áµ£ 0áµ£).
      1:{ apply idl_smallest; auto.
          split right; eauto.
          * intros ? ? -> ->; ring.
          * intros ? ? ->; ring. }
      right.
      intros H1.
      apply zero_not_one, Hl', Hl; now right.
  Qed.

  Corollary noetherian_nc_implies_XM : noetherian_nc ğ“¡ â†’ âˆ€P, P âˆ¨ Â¬ P.
  Proof.
    intros ? P.
    destruct (finitely_gen__discriminate P) as (? & []); eauto.
  Qed.

  Corollary principal_nc_implies_XM : principal_nc ğ“¡ â†’ âˆ€P, P âˆ¨ Â¬ P.
  Proof. intro; now apply noetherian_nc_implies_XM, principal__noetherian_nc. Qed.

End noetherian_nc_is_meaningless_constructivelly.

Check noetherian_nc_implies_XM.
