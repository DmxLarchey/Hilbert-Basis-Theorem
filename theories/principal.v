(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Stdlib Require Import List Ring ZArith Znumtheory Setoid Utf8.

Require Import utils ring ideal.

Import ListNotations.

Set Implicit Arguments.

(** Divisibility in a ring *)

Definition ring_div {ùì° : ring} (x y : ùì°) := ‚àÉd, y ‚àº·µ£ d *·µ£ x .

Notation "x |·µ£ y" := (ring_div x y) (at level 70, no associativity, format "x  |·µ£  y").

Add Parametric Morphism (ùì° : ring) : (@ring_div ùì°) with signature (req) ==> (req) ==> (iff) as ring_div_a_morph.
Proof.
  intros x y E a b F; split; intros (k & H); exists k.
  + rewrite <- F, H, <- E; reflexivity.
  + rewrite E, <- H, F; reflexivity.
Qed.

Section ring_div.

  Variable (ùì° : ring).

  Add Ring ùì°_is_ring : (is_ring ùì°).

  Implicit Type (x y : ùì°).

  Fact ring_div_refl x : x |·µ£ x.
  Proof. exists un_m; ring. Qed.

  Fact ring_div_trans x y z : x |·µ£ y ‚Üí y |·µ£ z ‚Üí x |·µ£ z.
  Proof. intros (a & ->) (b & ->); exists (op_m a b); ring. Qed.

  Fact ring_div_ideal x : ring_ideal (Œª y, x |·µ£ y).
  Proof.
    split right.
    + intros ? ? ->; auto.
    + exists un_a; ring.
    + intros ? ? (a & ->) (b & ->); exists (op_a a (iv_a b)); ring.
    + intros u v (a & ->); exists (op_m a u); ring.
  Qed.

End ring_div.

(** Principal ideals are mono-generated ideals 

    We define constructivelly principal rings as those where
    each finitely generated ideal is principal. *)

Section principal.

  Variable (ùì° : ring).

  Add Ring ùì°_is_ring : (is_ring ùì°).

  Definition principal_ideal (P : ùì° ‚Üí Prop) :=
    ‚àÉg, P ‚â°‚ÇÅ Œª y, g |·µ£ y.

  Fact principal_ideal__ring_ideal P : principal_ideal P ‚Üí ring_ideal P.
  Proof.
    intros (g & Hg); split right.
    + intros u v E H%Hg; apply Hg; now rewrite <- E.
    + apply Hg; exists un_a; ring.
    + intros u v (a & Ha)%Hg (b &Hb)%Hg; apply Hg.
      exists (op_a a (iv_a b)).
      rewrite Ha, Hb; ring.
    + intros u v (a & Ha)%Hg; apply Hg.
      exists (op_m u a).
      rewrite Ha; ring.
  Qed.

  (* This is not the classical characterization which
     would be every ideal is principal. Here, just every
     finitely generated ideal is principal. *)

  Definition principal := ‚àÄl, principal_ideal (Idl ‚åûl‚åü).

  (* Actually, to establish principality, it is enough to show Bezout, 
     i.e. the ideal generated by two elements is mono-generated *) 
  Lemma bezout__principal :
       (‚àÄ a b, ‚àÉp : ùì°, lc [a;b] ‚â°‚ÇÅ ring_div p)
     ‚Üí principal.
  Proof.
    intros H l.
    induction l as [ | x l (g & Hg) ].
    + exists un_a; intros x; split.
      * revert x; apply Idl_smallest.
        - apply principal_ideal__ring_ideal; exists un_a; tauto.
        - now simpl.
      * intros (a & ->).
        constructor 2 with un_a.
        - ring.
        - constructor 3.
    + destruct (H g x) as (h & Hh).
      exists h; intros y.
      rewrite Idl_iff_lc__list, <- Hh; split.
      * rewrite lc_inv_2.
        intros (a & r & (k & Hk)%Idl_iff_lc__list%Hg & H2)%lc_inv.
        exists k, a; rewrite <- H2, <- Hk; ring.
      * intros (a & b & <-)%lc_inv_2.
        constructor 2 with b (op_m a g); try ring.
        apply Idl_iff_lc__list, Hg; exists a; ring.
  Qed.

End principal.

Arguments principal_ideal {_}.

Section quotient_principal.

  (* Quotient preserve principal rings *)

  Variable (ùì° : ring)
           (rel : ùì° ‚Üí ùì° ‚Üí Prop)
           (rel_ovr : req ‚äÜ‚ÇÇ rel) 
           (rel_eqv : Equivalence rel)
           (rel_ext : @ring_eq_ext _ op_a op_m iv_a rel).

  Add Ring ùì°_is_ring : (is_ring ùì°).
  Add Ring Q_is_ring : (is_ring (@quotient_ring ùì° rel rel_ovr rel_eqv rel_ext)).

  Hypothesis Hùì° : principal ùì°.

  Fact quotient_principal : principal (@quotient_ring _ rel rel_ovr rel_eqv rel_ext).
  Proof.
    apply bezout__principal.
    intros a b.
    destruct (Hùì° [a;b]) as (g & Hg).
    assert (exists u v : ùì°, op_a (op_m u a) (op_m v b) ‚àº·µ£ g) as (u1 & v1 & Hg').
    1:{ apply lc_inv_2, Idl_iff_lc__list, Hg; exists un_m; ring. }
    exists g; intros x; split.
    + intros (u & v & E)%lc_inv_2; simpl in E.
      assert (ring_div g (op_a (op_m u a) (op_m v b)))
        as (h & Hh).
      * apply Hg, Idl_iff_lc__list.
        simpl; apply lc_inv_2.
        exists u, v; reflexivity.
      * exists h.
        rewrite <- E.
        apply rel_ovr in Hh.
        change ( 
         (@op_a (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) u a)
         (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) v b)) 
         ‚àº·µ£ (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) h g) ) in Hh.
        rewrite -> Hh; reflexivity.
    + intros (k & ->).
      apply lc_inv_2.
      exists (op_m k u1), (op_m k v1).
      apply rel_ovr in Hg'.
      change (@op_a (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) 
                    (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) u1 a) 
                    (@op_m (@quotient_ring _ rel rel_ovr rel_eqv rel_ext) v1 b) ‚àº·µ£ g) 
        in Hg'.
      rewrite <- Hg'.
      ring.
  Qed.

End quotient_principal.

(** Using Bezout's identity, we show that Z is a principal ring *)
Theorem Z_principal : principal Z_ring.
Proof.
  apply bezout__principal.
  intros a b.
  generalize (extgcd_correct a b).
  destruct (extgcd a b) as ((u,v),g); intros H.
  specialize (H _ _ _ eq_refl).
  destruct H as (B & ->).
  exists (Z.gcd a b); split.
  + intros (p & q & E)%lc_inv_2; simpl in E; subst x.
    apply Z.divide_add_r; apply Z.divide_mul_r.
    * apply Z.gcd_divide_l.
    * apply Z.gcd_divide_r.
  + intros (k & ->).
    rewrite <- B.
    apply lc_inv_2.
    exists (k*u), (k*v); simpl; ring.
Qed.

(** Notice that Z[X] is "not a principal ring" because
    the ideal generated by P := 2 and Q := X is not
    principal:
   
    Let us assume that Idl [2;X] were principal, hence
    generated by some polynomial G.
    
    Hence G divides 2 so G is in {-2,-1,1,2}
    But G divides X, hence the head coefficient of G 
    divides that of X, hence G can only be either -1 or 1.
    
    So if Idl [2;X] were principal, then it would
    be generated by 1 (or -1) and hence would be 
    all of Z[X]. Hence 1 belongs to Idl [2;X]
    
    Now let us how that 1 is not a linear combination of 2 and X
    We assume U and V in Z[X] such that U.2+V.X = 1 and derive 
    a contradiction:
    
    We instanciate/evaluate X := 0, we get U(0).2 = 1 in Z
    meaning 2 would divide 1 which is the contradiction we need. 
    
    Notice that Z/pqZ with p prime and q > 1 is a principal
    ring (as a quotient ring). However (Z/pqZ)[X] is not principal
    
    Indeed, let us assume that Idl [p.X‚Å∞;1.X¬π] is a principal
    ideal. Then let G be a generator of that ideal.
    We have G divides p.X‚Å∞ so the degree of G is less that 0
    so G = k.X‚Å∞ for some k. Now G divides 1.X¬π so the head
    coefficient of G divides the head coefficient of 1.X¬π hence
    k divides 1. So k is invertible in Z/pqZ, ie gcd(k,pq) = 1.
    
    G is a linear combination of p.X‚Å∞ and 1.X¬π so there is
    U,V in (Z/pqZ)[X] st p.U + X.U = kX‚Å∞. Intanciating
    X with 0, we get p.U(0) = k. Hence p divides k and thus
    divides gcd (k,pq). So p divides 1, hence cannot be prime.
    
    Thm: Z/mZ is principal. But (Z/mZ)[X] is principal if and
         only if Z/mZ is a field, ie m is prime.
*)

(*  
    But by Hilbert's Basis Theorem, Z[X‚ÇÅ,...,X‚Çô] is a Noetherian ring
*)
    
(*
    Btw, we can derive Dickson's lemma from the HBT:
    
    to the n-uplet (p‚ÇÅ,...,p‚Çô) of N^n we associate
    the monomial X^p‚ÇÅ...X^p‚Çô in Z[X‚ÇÅ,...,X‚Çô]. Hence
    a sequence of n-uplet gives rise to a sequence
    of monomials that cannot be forever free of linear
    combinations, according to the HBT. In turn, such
    a linear combination gives a good pair ?

    M‚Çö‚Çä‚ÇÅ = A‚ÇÅ.M‚ÇÅ + ... + A‚Çö.M‚Çö
    
    implies one of the M‚ÇÅ,..,M‚Çö is lesser than M‚Çö‚Çä‚ÇÅ
    on all components
    
    
    
*)




  

